{"version":3,"file":"can-interface.js","sourceRoot":"/","sources":["can-interface.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,qDAAuC;AACvC,qDAA2C;AAE3C,mCAAsC;AAiBtC;;GAEG;AACH,MAAa,YAAa,SAAQ,qBAAY;IAK5C,YAAa,OAAsB;QACjC,KAAK,EAAE,CAAC;QAJF,YAAO,GAAgC,IAAI,CAAC;QAC5C,YAAO,GAAY,KAAK,CAAC;QAK/B,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IACzB,CAAC;IAED;;;;OAIG;IACI,KAAK;QACV,IAAI;YACF,IAAI,CAAC,OAAO,GAAG,SAAS,CAAC,gBAAgB,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;YAChF,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,WAAW,EAAE,IAAI,CAAC,YAAY,CAAC,CAAC;YACzD,IAAI,CAAC,OAAO,CAAC,WAAW,CAAC,WAAW,EAAE,IAAI,CAAC,aAAa,CAAC,CAAC;YAC1D,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;SACtB;QAAC,OAAO,GAAG,EAAE;YACZ,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,gCAAgC,GAAG,GAAG,CAAC,CAAC;YAC/D,OAAO,KAAK,CAAC;SACd;QAED,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC;QACpB,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;OAIG;IACI,IAAI;QACT,IAAI,IAAI,CAAC,OAAO,EAAE;YAChB,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,CAAC;YACpB,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;SACtB;IACH,CAAC;IAED;;;OAGG;IACI,OAAO;QACZ,OAAO,IAAI,CAAC,OAAO,IAAI,IAAI,CAAC,OAAO,KAAK,IAAI,CAAC;IAC/C,CAAC;IAED;;;;;;;OAOG;IACI,IAAI,CAAE,EAAU,EAAE,GAAY,EAAE,IAAY,EAAE,GAAa;QAChE,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACjB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,yDAAyD,CAAC,CAAC;YACjF,OAAO,KAAK,CAAC;SACd;QAED,MAAM,GAAG,GAAyB;YAChC,EAAE,EAAE,EAAE;YACN,GAAG,EAAE,GAAG;YACR,GAAG,EAAE,CAAC,CAAC,GAAG;YACV,IAAI,EAAE,IAAI;SACX,CAAC;QACF,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,wBAAwB,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QAEtE,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QAEvB,OAAO,IAAI,CAAC;IACd,CAAC;IAGO,YAAY,CAAE,GAAyB;QAC7C,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK,CAAC,yBAAyB,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QAEvE,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC;IAC5B,CAAC;IAGO,aAAa;QACnB,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;QACrB,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;IACvB,CAAC;CACF;AAXC;IADC,0BAAQ;gDAKR;AAGD;IADC,0BAAQ;iDAIR;AAzFH,oCA0FC","sourcesContent":["import * as socketcan from 'socketcan';\nimport { autobind } from 'core-decorators';\nimport { CanBusAdapter } from './main';\nimport { EventEmitter } from 'events';\n\ninterface CanInterfaceEvents {\n  'message': (msg: socketcan.CanMessage) => void;\n  'stopped': () => void;\n}\n\nexport declare interface CanInterface {\n  on<U extends keyof CanInterfaceEvents>(\n    event: U, listener: CanInterfaceEvents[U]\n  ): this;\n\n  emit<U extends keyof CanInterfaceEvents>(\n    event: U, ...args: Parameters<CanInterfaceEvents[U]>\n  ): boolean;\n}\n\n/**\n * Interface to the CAN bus using socketcan.\n */\nexport class CanInterface extends EventEmitter {\n  private adapter: CanBusAdapter;\n  private channel: socketcan.RawChannel | null = null;\n  private started: boolean = false;\n\n  constructor (adapter: CanBusAdapter) {\n    super();\n\n    this.adapter = adapter;\n  }\n\n  /**\n   * Create and start the channel of the CAN interface.\n   * Need to be called before we can send/receive any messages.\n   * @return `true` if the channel is started, `false` in case of an error.\n   */\n  public start (): boolean {\n    try {\n      this.channel = socketcan.createRawChannel(this.adapter.config.interface, false);\n      this.channel.addListener('onMessage', this.handleCanMsg);\n      this.channel.addListener('onStopped', this.handleStopped);\n      this.channel.start();\n    } catch (err) {\n      this.adapter.log.error(`Error starting can interface: ` + err);\n      return false;\n    }\n\n    this.started = true;\n    return true;\n  }\n\n  /**\n   * Stop the channel of the CAN interface.\n   * If stopped no more messages will be received but it may be possible to send\n   * messages anyways.\n   */\n  public stop (): void {\n    if (this.channel) {\n      this.channel.stop();\n      this.started = false;\n    }\n  }\n\n  /**\n   * Check if the interface is ready to send/receive data.\n   * @return `true` if ready.\n   */\n  public isReady (): boolean {\n    return this.started && this.channel !== null;\n  }\n\n  /**\n   * Send a can message with the given properties.\n   * @param id The nummeric ID of the CAN message.\n   * @param ext `true` if the message should be send in extended frame format.\n   * @param data The data of the message. 0 to 8 bytes buffer.\n   * @param rtr Remote transmission request flag.\n   * @return `true` if the message is sent.\n   */\n  public send (id: number, ext: boolean, data: Buffer, rtr?: boolean): boolean {\n    if (!this.channel) {\n      this.adapter.log.warn(`Could not send data because channel is not initialized.`);\n      return false;\n    }\n\n    const msg: socketcan.CanMessage = {\n      id: id,\n      ext: ext,\n      rtr: !!rtr,\n      data: data\n    };\n    this.adapter.log.debug(`sending can message: ${JSON.stringify(msg)}`);\n\n    this.channel.send(msg);\n\n    return true;\n  }\n\n  @autobind\n  private handleCanMsg (msg: socketcan.CanMessage): void {\n    this.adapter.log.debug(`received can message: ${JSON.stringify(msg)}`);\n\n    this.emit('message', msg);\n  }\n\n  @autobind\n  private handleStopped (): void {\n    this.started = false;\n    this.emit('stopped');\n  }\n}\n"]}