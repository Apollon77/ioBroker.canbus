{"version":3,"file":"boolean.js","sourceRoot":"/","sources":["parsers/boolean.ts"],"names":[],"mappings":";;;AACA,iCAAoC;AAEpC;;GAEG;AACH,MAAa,aAAc,SAAQ,iBAAU;IAM3C,YAAY,OAAsB,EAAE,YAAiD;QACnF,KAAK,CAAC,OAAO,EAAE,YAAY,CAAC,CAAC;IAC/B,CAAC;IAEM,KAAK,CAAC,IAAI,CAAC,GAAW;QAC3B,IAAI,IAAI,CAAC,GAAG,CAAC,UAAU,IAAI,GAAG,CAAC,MAAM,EAAE;YACrC,OAAO,IAAI,KAAK,CAAC,oCAAoC,CAAC,CAAC;SACxD;QAED,MAAM,GAAG,GAAG,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;QACrC,IAAI,GAAY,CAAC;QACjB,IAAI,IAAI,CAAC,GAAG,CAAC,WAAW,KAAK,CAAC,EAAE;YAC9B,wCAAwC;YACxC,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;SACjB;aAAM;YACL,oBAAoB;YACpB,GAAG,GAAG,CAAC,CAAC,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,KAAK,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;SAC/D;QAED,UAAU;QACV,IAAI,IAAI,CAAC,GAAG,CAAC,aAAa,EAAE;YAC1B,GAAG,GAAG,CAAC,GAAG,CAAC;SACZ;QAED,OAAO,GAAG,CAAC;IACb,CAAC;IAEM,KAAK,CAAC,KAAK,CAAC,GAAW,EAAE,GAAY;QAC1C,IAAI,IAAI,CAAC,GAAG,CAAC,UAAU,IAAI,GAAG,CAAC,MAAM,EAAE;YACrC,OAAO,IAAI,KAAK,CAAC,oCAAoC,CAAC,CAAC;SACxD;QAED,UAAU;QACV,IAAI,IAAI,CAAC,GAAG,CAAC,aAAa,EAAE;YAC1B,GAAG,GAAG,CAAC,GAAG,CAAC;SACZ;QAED,IAAI,IAAI,CAAC,GAAG,CAAC,WAAW,KAAK,CAAC,EAAE;YAC9B,oDAAoD;YACpD,IAAI,GAAG,EAAE;gBACP,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC;aACjC;iBAAM;gBACL,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC;aACjC;SACF;aAAM;YACL,8EAA8E;YAC9E,IAAI,GAAG,EAAE;gBACP,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;aAC9E;iBAAM;gBACL,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC,CAAC;aACjF;SACF;QAED,OAAO,GAAG,CAAC;IACb,CAAC;;AA5DH,sCA6DC;AA3D2B,8BAAgB,GAAqC;IAC7E,SAAS;CACV,CAAC","sourcesContent":["import { CanBusAdapter } from '../main';\nimport { ParserBase } from './base';\n\n/**\n * Parser for handling of boolean values.\n */\nexport class ParserBoolean extends ParserBase {\n\n  protected static readonly handledDataTypes: ioBroker.AdapterConfigDataType[] = [\n    'boolean'\n  ];\n\n  constructor(adapter: CanBusAdapter, parserConfig: ioBroker.AdapterConfigMessageParser) {\n    super(adapter, parserConfig);\n  }\n\n  public async read(buf: Buffer): Promise<boolean | Error> {\n    if (this.cfg.dataOffset >= buf.length) {\n      return new Error('Data is too short for given offset');\n    }\n\n    const val = buf[this.cfg.dataOffset];\n    let ret: boolean;\n    if (this.cfg.booleanMask === 0) {\n      // any value greater than 0 will be true\n      ret = (val > 0);\n    } else {\n      // check the bitmask\n      ret = ((val & this.cfg.booleanMask) === this.cfg.booleanMask);\n    }\n\n    // invert?\n    if (this.cfg.booleanInvert) {\n      ret = !ret;\n    }\n\n    return ret;\n  }\n\n  public async write(buf: Buffer, val: boolean): Promise<Buffer | Error> {\n    if (this.cfg.dataOffset >= buf.length) {\n      return new Error('Data is too short for given offset');\n    }\n\n    // invert?\n    if (this.cfg.booleanInvert) {\n      val = !val;\n    }\n\n    if (this.cfg.booleanMask === 0) {\n      // set the byte to 0xff or 0x00 if no bitmask is set\n      if (val) {\n        buf[this.cfg.dataOffset] = 0xff;\n      } else {\n        buf[this.cfg.dataOffset] = 0x00;\n      }\n    } else {\n      // set/clear the bits defined in the bitmask and keep the other bits untouched\n      if (val) {\n        buf[this.cfg.dataOffset] = (buf[this.cfg.dataOffset] | this.cfg.booleanMask);\n      } else {\n        buf[this.cfg.dataOffset] = (buf[this.cfg.dataOffset] & ~(this.cfg.booleanMask));\n      }\n    }\n\n    return buf;\n  }\n}"]}